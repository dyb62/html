module.exports.parse = async (raw, { yaml }) => {
  const config = yaml.parse(raw);
  const proxies = config.proxies || [];

  // 定义你想要的地区和对应的正则
  const regions = [
    { name: "HK-自动选择(Smart Group)", regex: /(?i)(港|HK|Hong)/ },
    { name: "TW-自动选择(Smart Group)", regex: /(?i)(台|TW|Tai)/ },
    { name: "JP-自动选择(Smart Group)", regex: /(?i)(日|JP|Japan)/ },
    { name: "SG-自动选择(Smart Group)", regex: /(?i)(新|SG|Sing)/ },
    { name: "US-自动选择(Smart Group)", regex: /(?i)(美|US|United)/ },
    { name: "UK-自动选择(Smart Group)", regex: /(?i)(英|UK|Kingdom)/ },
    { name: "DE-自动选择(Smart Group)", regex: /(?i)(德|DE|Ger)/ },
    { name: "FR-自动选择(Smart Group)", regex: /(?i)(法|FR|France)/ },
    { name: "NL-自动选择(Smart Group)", regex: /(?i)(荷|NL|Neth)/ },
    { name: "BR-自动选择(Smart Group)", regex: /(?i)(巴西|BR|Brazil)/ },
    { name: "ALL-自动选择(Smart Group)", regex: /.*/ } // 包含所有节点
  ];

  // 确保 proxy-groups 存在
  if (!config['proxy-groups']) {
    config['proxy-groups'] = [];
  }

  // 倒序插入，保证顺序（或者你可以创建一个新数组重新排列）
  // 这里我们将生成的组插入到列表的最前面
  const autoGroups = [];

  regions.forEach(region => {
    // 核心逻辑：检查现有节点中是否有符合该正则的
    // 只有当 hasNodes 为 true 时，才创建这个组
    const hasNodes = proxies.some(p => p.name.match(region.regex));

    if (hasNodes || region.name.includes("ALL")) {
      autoGroups.push({
        name: region.name,
        type: "url-test",
        url: "http://www.gstatic.com/generate_204",
        interval: 300,
        tolerance: 50,
        filter: region.regex.source // 使用正则筛选节点
        // 如果你需要包含 provider 中的节点，这里不需要改动，
        // 因为 filter 是作用于全局节点池的（如果在 use 模式下逻辑不同，通常 filter 够用）
      });
    }
  });

  // 将自动组添加到 proxy-groups 的最前面
  config['proxy-groups'] = [...autoGroups, ...config['proxy-groups']];

  // 可选：如果你希望这些自动组也被加入到“漏网之鱼”或“Proxy”主策略组中
  // const mainGroup = config['proxy-groups'].find(g => g.name === 'Proxy' || g.name === '节点选择');
  // if (mainGroup) {
  //    mainGroup.proxies = [...autoGroups.map(g => g.name), ...mainGroup.proxies];
  // }

  return yaml.stringify(config);
};
